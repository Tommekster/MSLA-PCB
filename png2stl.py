from pathlib import PurePath
from skimage import measure
from stl import mesh
import numpy as np
import argparse
import cv2
import os


def get_local_folder():
    """
    Returns the PurePath of the project folder
    """

    try:
        return PurePath(os.path.dirname(os.path.realpath(__file__)))  # py
    except NameError:
        pass
    return os.path.abspath("")  # ipynb


def _unpad(x, pad_width):
    slices = []
    for c in pad_width:
        e = None if c[1] == 0 else -c[1]
        slices.append(slice(c[0], e))
    return x[tuple(slices)]


def preprocess (image, invert=False, hmirror=False, vmirror=True, threshold=255//2):
    """
    Prepares the image for the conversion

    Attributes
    ----------
    image: np.array
        Numpy array containing an rgb image
    
    invert: bool
        True if we have to invert the image; input images should be black (traces) 
        on white (non-conductive surface)

    hmirror: bool
        True if we have to horizontally mirror the image

    vmirror: bool
        True if we have to vertically mirror the image; this needs to be done
        in order to successfully print a circuit with a SLA printer

    Returns
    -------
    The preprocessed image ready to be converted to a 3d object

    Throws
    ------
    ValueError
        if the input is not a suitable numpy array
    """

    if len(image.shape) < 2 or len(image.shape) > 3:
        raise ValueError(f'Invalid shape [{image.shape}] for image array')

    # grayscale the image
    if len(image.shape) == 3:
        image = np.mean(image, axis=2, dtype=int)

    # threshold the image so that we end up with only two colors, black and white
    image[image >= threshold] = 255
    image[image < threshold] = 0

    # pdfs generated by cad softwares often come with a border

    # find top padding
    top_padding = -1
    previous_row_content = np.unique(image[0])
    for i in range(1, len(image)):
        current_row_content = np.unique(image[i])
        if not np.array_equal(current_row_content, previous_row_content):
            break
        previous_row_content = current_row_content
        top_padding += 1

    # find bottom padding
    bottom_padding = -1
    previous_row_content = np.unique(image[-1])
    for i in range(len(image) - 1, 0, -1):
        current_row_content = np.unique(image[i])
        if not np.array_equal(current_row_content, previous_row_content):
            break
        previous_row_content = current_row_content
        bottom_padding += 1

    # find left padding
    left_padding = -1
    previous_col_content = np.unique(image[:, 0])
    for i in range(1, len(image[0])):
        current_col_content = np.unique(image[:, i])
        if not np.array_equal(current_col_content, previous_col_content):
            break
        previous_col_content = current_col_content
        left_padding += 1

    # find right padding
    right_padding = -1
    previous_col_content = np.unique(image[:, -1])
    for i in range(len(image[0]) - 1, 1, -1):
        current_col_content = np.unique(image[:, i])
        if not np.array_equal(current_col_content, previous_col_content):
            break
        previous_col_content = current_col_content
        right_padding += 1

    pad = ((top_padding, bottom_padding),(left_padding, right_padding))

    # unpad
    image = _unpad(image, pad)

    if invert:
        image = ~image

    if hmirror:
        image = np.flip(image, 0)

    if vmirror:
        image = np.flip(image, 1)
    
    return image


def numpy_to_stl(mask, output_shape):
    """
    Converts the 3d mask into a 3d object using the marching cube
    algorithm. The 3d object will have the dimensions specified
    by the output_shape parameter (mm).

    Attributes
    ----------
    mask: np.array
        2d nunpy array to erode into a 3d stl object
    
    output_shape: int tuple
        size in mm of the output 3d object

    Returns
    -------
    The 3d stl object
    """

    width, depth, height = output_shape

    mask = np.repeat(mask[:, :, np.newaxis], 3, axis=2)

    # contour of the object
    mask = np.pad(mask, ((1, 1), (1, 1), (1, 1)), constant_values=True)

    #import matplotlib.pyplot as plt
    #plt.imshow(mask[:, :, 1])

    # create the 3d meshgrid
    shp = mask.shape
    x = np.linspace(0, width, shp[1])
    y = np.linspace(0, depth, shp[0])
    z = np.linspace(0, height, shp[2])

    # get vertices and faces
    verts, faces, normals, values = measure.marching_cubes(mask)

    # scaling
    dx = np.diff(x)[0]
    dy = np.diff(y)[0]
    dz = np.diff(z)[0]
    dr = np.array([dx, dy, dz])
    verts = verts * dr

    # build the 3d object
    obj_3d = mesh.Mesh(np.zeros(faces.shape[0], dtype=mesh.Mesh.dtype))
    for i, f in enumerate(faces):
        obj_3d.vectors[i] = verts[f]

    return obj_3d


if __name__ == '__main__':

    # ----------------------------- argument handling ---------------------------- #

    parser = argparse.ArgumentParser()

    # sample command: python png2stl.py path/to/png.png width(mm) height(mm) depth(mm)
    parser.add_argument('filename') # e.g. ./samples/load_sharing_panelized.png
    parser.add_argument('size', nargs='+', type=int) # e.g. 18 25 1

    args = parser.parse_args()

    size = tuple(args.size)
    input_path = PurePath(args.filename)

    # ----------------------------------- main ----------------------------------- #

    stem = input_path.stem
    folder = input_path.parent

    img = cv2.imread(str(input_path))

    # we have the image as a numpy array, remove external padding
    # and apply other preprocessing steps
    img = preprocess(img, invert=False)

    # convert the image to 
    obj_3d = numpy_to_stl(img, size) # (width, depth, height)

    output_file = PurePath(folder, stem + '.stl')
    obj_3d.save(str(output_file))
